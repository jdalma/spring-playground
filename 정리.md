
# 코루틴 + WebClient 학습 정리

## 1. 프로젝트 구성

### coroutine-sample 모듈 생성
- 루트 프로젝트에 `coroutine-sample` 멀티 모듈 추가
- `settings.gradle.kts`에 모듈 등록
- Kotlin + Spring Boot 의존성 설정
  - spring-boot-starter-web
  - spring-boot-starter-webflux  
  - kotlinx-coroutines-core
  - kotlinx-coroutines-reactor
  - kotlinx-coroutines-reactive

### 기본 구조
```
coroutine-sample/
├── src/main/kotlin/example/
│   ├── CoroutineSampleApplication.kt
│   ├── config/WebClientConfig.kt
│   └── controller/
│       ├── TestController.kt
│       └── ClientController.kt
├── src/main/resources/application.yml
└── build.gradle.kts
```

## 2. 구현한 API들

### TestController
- `GET /test`: 10초 sleep 후 "success" 반환 (blocking 방식)

### ClientController  
- `GET /client/test`: WebClient + 코루틴으로 /test API 호출
- `GET /client/resttemplate-test`: RestTemplate + 코루틴으로 /test API 호출

## 3. 비동기 처리 방식 비교

### WebClient + 코루틴 (논블로킹)
```kotlin
suspend fun callTest(): String {
    return coroutineScope {
        val webClientCall = async { getWebClientCall() }
        val otherWork = async { /* 다른 작업 */ }
        val additionalWork = async { /* 추가 작업 */ }
        
        // 모든 작업이 동시에 실행됨
        val webResult = webClientCall.await()
        val otherResult = otherWork.await()  
        val additionalResult = additionalWork.await()
        
        webResult
    }
}
```

### RestTemplate + 코루틴 (블로킹)
```kotlin
fun callTestWithRestTemplate(): String {
    return runBlocking {
        val restTemplateCall = async { getRestTemplateCall() }
        val otherWork = async { /* 다른 작업 */ }
        
        // RestTemplate은 내부적으로 쓰레드를 블로킹
        restTemplateCall.await()
    }
}
```

## 4. 핵심 개념 정리

### WebClient의 논블로킹 특성
- **코루틴 없이도 논블로킹**: WebClient 자체가 리액티브 스트림 기반
- **리턴 타입에 따른 차이**:
  - `block()` 호출 시: 블로킹
  - `Mono/Flux` 리턴: 논블로킹
  - `awaitSingle()` 사용: 논블로킹 + 동기식 코드 스타일

### 코루틴의 장점: 콜백 지옥 해결

**리액티브 스트림 방식 (복잡함)**:
```kotlin
webClient.get().uri("/users/$userId")
    .flatMap { user ->
        webClient.get().uri("/orders/${user.id}")
            .flatMap { orders ->
                webClient.get().uri("/details/${orders.id}")
                    .map { details -> /* 중첩된 콜백 */ }
            }
    }
```

**코루틴 방식 (직관적)**:
```kotlin
suspend fun processUserOrders(userId: String) {
    val user = fetchUser(userId)        // 순차적 실행
    val orders = fetchOrders(user.id)   // 하지만 내부적으로는 비동기
    val details = fetchOrderDetails(orders.id)
}
```

### 코루틴의 일시정지/재개 메커니즘
1. **일시정지**: `suspend` 함수 호출 시 코루틴이 일시정지, 쓰레드는 해제
2. **재개**: 비동기 작업 완료 시 코루틴 재개, 로컬 변수 상태 보존
3. **결과**: 비동기 코드를 동기 코드처럼 순차적으로 작성 가능

### WebClient와 suspend의 관계
- **WebClient 자체에는 suspend 함수가 없음**
- **핵심은 `awaitSingle()` 확장함수** (`kotlinx-coroutines-reactor` 제공)

```kotlin
// WebClient 원본 API - suspend 아님
fun bodyToMono(clazz: Class<T>): Mono<T>

// awaitSingle()이 Mono를 suspend 함수로 변환
suspend fun <T> Mono<T>.awaitSingle(): T
```

### awaitSingle() 상세 분석

#### awaitSingle()이란?
- `kotlinx-coroutines-reactor` 라이브러리의 **확장함수**
- **Mono<T>를 suspend fun으로 변환**하는 브리지 역할
- 리액티브 스트림과 코루틴을 연결하는 핵심 메커니즘

#### awaitSingle() 내부 구현 개념
```kotlin
// 실제 구현은 더 복잡하지만 개념적으로는 이런 방식
suspend fun <T> Mono<T>.awaitSingle(): T = suspendCoroutine { continuation ->
    this.subscribe(
        onNext = { value -> continuation.resume(value) },
        onError = { error -> continuation.resumeWithException(error) }
    )
}
```

#### 동작 과정 상세
1. **코루틴 일시정지**:
   ```kotlin
   suspend fun callApi(): String {
       // 여기까지는 정상 실행
       return webClient.get().uri("/test")
           .bodyToMono(String::class.java)
           .awaitSingle() // 여기서 일시정지!
       // 이 줄은 나중에 실행됨
   }
   ```

2. **Mono 구독 시작**:
   - awaitSingle()이 내부적으로 `mono.subscribe()` 호출
   - HTTP 요청이 실제로 시작됨
   - 코루틴은 일시정지 상태, 쓰레드는 해제되어 다른 작업 처리 가능

3. **비동기 응답 처리**:
   ```kotlin
   // HTTP 응답이 오면
   onNext = { result -> 
       continuation.resume(result) // 코루틴 재개
   }
   onError = { error -> 
       continuation.resumeWithException(error) // 예외로 재개
   }
   ```

4. **코루틴 재개**:
   - HTTP 응답이 도착하면 콜백이 호출됨
   - `continuation.resume()`으로 코루틴이 재개됨
   - `awaitSingle()`이 실제 값을 리턴

#### 다른 await 함수들
```kotlin
// Mono용
suspend fun <T> Mono<T>.awaitSingle(): T           // 단일 값
suspend fun <T> Mono<T>.awaitSingleOrNull(): T?    // null 허용

// Flux용  
suspend fun <T> Flux<T>.awaitFirst(): T            // 첫 번째 값
suspend fun <T> Flux<T>.awaitLast(): T             // 마지막 값
suspend fun <T> Flux<T>.awaitSingle(): T           // 정확히 하나의 값
fun <T> Flux<T>.asFlow(): Flow<T>                  // Flow로 변환
```

#### awaitSingle() 없이 사용하는 경우
```kotlin
// 1. block() 사용 - 블로킹 방식 (권장 안 함)
fun callApiBlocking(): String {
    return webClient.get().uri("/test")
        .bodyToMono(String::class.java)
        .block()!! // 쓰레드가 블로킹됨
}

// 2. 콜백 방식 - 전통적인 리액티브
fun callApiReactive(): Mono<String> {
    return webClient.get().uri("/test")
        .bodyToMono(String::class.java)
        .doOnNext { result -> println("결과: $result") }
        .doOnError { error -> println("에러: $error") }
}

// 3. awaitSingle() 사용 - 코루틴 방식 (권장)
suspend fun callApiCoroutine(): String {
    return webClient.get().uri("/test")
        .bodyToMono(String::class.java)
        .awaitSingle() // 논블로킹이면서 동기식 코드
}
```

### 내부 동작 과정
1. **WebClient 호출**: `bodyToMono()` → 즉시 `Mono<String>` 리턴 (논블로킹)
2. **awaitSingle() 호출**: 
   - 코루틴 일시정지
   - Mono 구독(subscribe) 시작
   - 쓰레드 해제
3. **HTTP 응답 도착**:
   - Mono가 값 emit
   - 코루틴 재개  
   - 실제 String 값 리턴

### 비교 예제
```kotlin
// suspend 없이 - Mono 그대로 리턴
fun callApiWithoutSuspend(): Mono<String> {
    return webClient.get()
        .uri("/test")
        .retrieve()
        .bodyToMono(String::class.java) // 아직 HTTP 호출 안 됨
}

// suspend + awaitSingle() - 실제 값 리턴
suspend fun callApiWithSuspend(): String {
    return webClient.get()
        .uri("/test")
        .retrieve()
        .bodyToMono(String::class.java)
        .awaitSingle() // 여기서 실제 HTTP 호출하고 결과 기다림
}
```

## 5. 비교 결과

| 방식 | 쓰레드 사용 | 코드 복잡도 | 성능 |
|------|-------------|-------------|------|
| RestTemplate + async | 블로킹 (비효율적) | 보통 | 낮음 |
| WebClient + Mono/Flux | 논블로킹 (효율적) | 높음 (콜백 지옥) | 높음 |
| WebClient + 코루틴 | 논블로킹 (효율적) | 낮음 (직관적) | 높음 |

## 6. 결론

- **WebClient + 코루틴** 조합이 최적
- 논블로킹 처리로 높은 성능
- 동기식 코드 스타일로 높은 가독성
- 복잡한 비즈니스 로직에서 유지보수성 향상
